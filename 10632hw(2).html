<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8" />
<title>簡易射擊遊戲</title>
<style>
body{margin:0;background:#222;display:flex;justify-content:center;align-items:center;height:100vh}
canvas{background:#fff;border:3px solid #000}
#mathInput{position:absolute;top:360px;left:50%;transform:translateX(-50%);font-size:20px;padding:5px;display:none}
#timer{position:absolute;top:330px;left:50%;transform:translateX(-50%);font-size:18px;color:red;display:none}
</style>
</head>
<body tabindex="0">
<canvas id="game" width="400" height="600"></canvas>
<input id="mathInput" placeholder="輸入答案並按 Enter" />
<div id="timer">10</div>
<script>
const canvas=document.getElementById('game');
const ctx=canvas.getContext('2d');
const mathInput=document.getElementById('mathInput');
const timerDisplay=document.getElementById('timer');

let score=0,gameOver=false,showQuestion=null;
let solvedMathCount=0;
let mathTimeLeft=10,mathTimer=null;
let skipNextDebuff=false;

const player={x:185,y:550,width:30,height:30,speed:5,ammo:10,hitCount:0};
let bullets=[],enemyBullets=[],enemies=[],cards=[],supplies=[];
let enemySpawnTimer=0,yellowDropTimer=0,supplyTimer=0;

function resetGame(){
 score=0;gameOver=false;showQuestion=null;solvedMathCount=0;skipNextDebuff=false;
 bullets=[];enemyBullets=[];enemies=[];cards=[];supplies=[];
 player.x=185;player.speed=5;player.ammo=10;player.hitCount=0;
 enemySpawnTimer=0;yellowDropTimer=0;supplyTimer=0;
 mathInput.style.display='none';timerDisplay.style.display='none';
 clearInterval(mathTimer);mathTimeLeft=10;
}

const keys={};
window.addEventListener('keydown',e=>{
 keys[e.code]=true;
 if(e.code==='Space')e.preventDefault();
 if(gameOver&&e.code==='KeyR')resetGame();
});
window.addEventListener('keyup',e=>keys[e.code]=false);

function spawnEnemy(){
 enemies.push({
  x: Math.random() * (canvas.width - 30),
  y: -30,
  width: 30,
  height: 30,
  speed: 2,
  shootTimer: 0
 });
}

function spawnCard(){
 cards.push({x:Math.random()*(canvas.width-20),y:-20,width:20,height:20,speed:2});
}

function startQuestion(){
 showQuestion={q:'3 + 5 = ?',a:'8'};
 mathInput.value='';
 mathInput.style.display='block';
 mathInput.focus();
 mathTimeLeft=10;
 timerDisplay.textContent=10;
 timerDisplay.style.display='block';
 clearInterval(mathTimer);
 mathTimer=setInterval(()=>{
  mathTimeLeft--;
  timerDisplay.textContent=mathTimeLeft;
  if(mathTimeLeft<=0){
   clearInterval(mathTimer);
   mathInput.style.display='none';
   timerDisplay.style.display='none';
   showQuestion=null;
  }
 },1000);
}

mathInput.addEventListener('keydown',e=>{
 if(e.key==='Enter'&&showQuestion){
  if(mathInput.value.trim()===showQuestion.a){
   solvedMathCount++;
  }else{
   player.speed=2;
   setTimeout(()=>player.speed=5,3000);
  }
  clearInterval(mathTimer);
  mathInput.style.display='none';
  timerDisplay.style.display='none';
  showQuestion=null;
 }
});

function update(){
 if(showQuestion||gameOver)return;

 enemySpawnTimer++;
 if(enemySpawnTimer>=60){spawnEnemy();enemySpawnTimer=0;}

 yellowDropTimer++;
 if(yellowDropTimer>=600){
  if(!skipNextDebuff){for(let i=0;i<3;i++)spawnCard();}
  skipNextDebuff=false;
  yellowDropTimer=0;
 }

 supplyTimer++;
 if(supplyTimer>=300){
  supplies.push({x:Math.random()*(canvas.width-20),y:-20,width:20,height:20,speed:2});
  supplyTimer=0;
 }

 if(keys.ArrowLeft&&player.x>0)player.x-=player.speed;
 if(keys.ArrowRight&&player.x<canvas.width-player.width)player.x+=player.speed;

 if(keys.Space&&player.ammo>0){
  bullets.push({x:player.x+12,y:player.y,w:6,h:10,s:6});
  player.ammo--;
  if(player.ammo<=0)gameOver=true;
  keys.Space=false;
 }

 bullets.forEach(b=>b.y-=b.s);
 bullets=bullets.filter(b=>b.y>-20);
 enemyBullets.forEach(b=>b.y+=b.s);
 enemyBullets=enemyBullets.filter(b=>b.y<canvas.height+20);

 enemies.forEach(e=>{
  e.y+=e.speed;
  e.shootTimer++;
  if(e.shootTimer>=90){
   enemyBullets.push({x:e.x+e.width/2-3,y:e.y+e.height,w:6,h:10,s:3});
   e.shootTimer=0;
  }
 });

 for(let i=enemies.length-1;i>=0;i--){
  for(let j=bullets.length-1;j>=0;j--){
   const e=enemies[i],b=bullets[j];
   if(b.x<e.x+e.width&&b.x+b.w>e.x&&b.y<e.y+e.height&&b.y+b.h>e.y){
    enemies.splice(i,1);bullets.splice(j,1);
    score++;player.ammo++;player.hitCount++;
    if(player.hitCount>=10){
     player.hitCount=0;
     const ans=prompt('是否跳過下一次題目？（是 / 否）');
     skipNextDebuff=(ans==='是');
    }
    break;
   }
  }
 }

 for(let i=enemyBullets.length-1;i>=0;i--){
  const b=enemyBullets[i];
  if(b.x<player.x+player.width&&b.x+b.w>player.x&&b.y<player.y+player.height&&b.y+b.h>player.y){
   gameOver=true;
  }
 }

 for(let i=cards.length-1;i>=0;i--){
  const c=cards[i];c.y+=c.speed;
  if(player.x<c.x+c.width&&player.x+player.width>c.x&&player.y<c.y+c.height&&player.y+player.height>c.y){
   cards.splice(i,1);startQuestion();
  }else if(c.y>canvas.height){cards.splice(i,1);}
 }

 for(let i=supplies.length-1;i>=0;i--){
  const s=supplies[i];s.y+=s.speed;
  if(player.x<s.x+s.width&&player.x+player.width>s.x&&player.y<s.y+s.height&&player.y+player.height>s.y){
   player.ammo++;supplies.splice(i,1);
  }else if(s.y>canvas.height){supplies.splice(i,1);}
 }
}

function draw(){
 ctx.clearRect(0,0,canvas.width,canvas.height);
 if(showQuestion){ctx.font='22px Arial';ctx.fillText(showQuestion.q,40,300);return;}
 if(gameOver){
  ctx.font='32px Arial';ctx.fillText('GAME OVER',90,250);
  ctx.font='18px Arial';ctx.fillText('按 R 重新開始',120,290);
  return;
 }
 ctx.fillStyle='blue';ctx.fillRect(player.x,player.y,player.width,player.height);
 ctx.fillStyle='red';bullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));
 ctx.fillStyle='orange';enemyBullets.forEach(b=>ctx.fillRect(b.x,b.y,b.w,b.h));
 ctx.fillStyle='green';enemies.forEach(e=>ctx.fillRect(e.x,e.y,e.width,e.height));
 ctx.fillStyle='yellow';cards.forEach(c=>ctx.fillRect(c.x,c.y,c.width,c.height));
 ctx.fillStyle='red';supplies.forEach(s=>ctx.fillRect(s.x,s.y,s.width,s.height));
 ctx.fillStyle='black';ctx.fillText('Score:'+score,10,30);
 ctx.fillText('Ammo:'+player.ammo,10,50);
 ctx.fillText('Solved:'+solvedMathCount,10,70);
}

function loop(){update();draw();requestAnimationFrame(loop);}loop();
</script>
</body>
</html>
